###
# required
# pvc_namespace
# pvc_name
# volume_name
# bound_pod_uid
# failed_pvcs: []
# successful_pvcs: []
# node_name
# mig_source_host:

- set_fact:
    mig_source_data_base_location: "/var/lib/origin/openshift.local.volumes"
    mig_source_data_location_k8s_mount: "kubernetes.io~glusterfs"

- set_fact:
    mig_dest_service_url: "{{ rsync_route.resources[0].spec.host }}"
    mig_dest_data_location: "/mnt/{{ pvc_ns }}/{{ pvc_name }}"
    mig_source_data_location: "{{ mig_source_data_base_location }}/pods/{{ bound_pod_uid }}/volumes/{{ mig_source_data_location_k8s_mount }}/{{ volume_name }}/"
    mig_source_host: "{{ node_name }}"
    mig_dest_ssh_key_remote_location: "~/.ssh/dest_key"

- delegate_to: "{{ mig_source_host|mandatory }}"
  tags:
    - sync_phase
    - final_phase
  block:
    - name: "Install stunnel"
      yum:
        name: stunnel
        state: latest
      become: true

    - name: "Write stunnel.conf"
      copy:
        content: |
          foreground = no
          pid =
          sslVersion = TLSv1.2
          client = yes
          syslog = no
          [ssh]
          accept = 2222
          CAFile = /etc/stunnel/tls.crt
          cert = /etc/stunnel/tls.crt
          connect = {{ mig_dest_service_url }}:443
          verify = 2
          key = /etc/stunnel/tls.key
        dest: /etc/stunnel/stunnel.conf
      become: true

    - name: "Write tls.crt"
      copy:
        content: "{{ stunnel_crt['content']|b64decode }}"
        dest: /etc/stunnel/tls.crt
      become: true

    - name: "Write tls.key"
      copy:
        content: "{{ stunnel_key['content']|b64decode }}"
        dest: /etc/stunnel/tls.key
        mode: 0600
      become: true

    - name: "Write stunnel.conf"
      copy:
        content: |
          [Unit]
          Description=TLS tunnel for network daemons
          After=syslog.target network.target

          [Service]
          ExecStart=/usr/bin/stunnel
          Type=forking
          PrivateTmp=true

          [Install]
          WantedBy=multi-user.target
        dest: /etc/stunnel/stunnel.conf
        become: true

    - name: "Start stunnel"
      systemd: "stunnel"
      state: restarted
      daemon_reload: yes


    - fail:
      when: stunnel_output.rc != 0

- delegate_to: "{{ mig_source_host|mandatory }}"
  ignore_errors: true
  tags:
  - sync_phase
  - final_phase
  block:
  - name: "Ensure .ssh directory on source node"
    file:
      path: "~/.ssh"
      state: directory
    become: yes

  - name: "Copying private key to source node"
    copy:
      src: "{{ mig_dest_ssh_private_key|mandatory }}"
      dest: "{{ mig_dest_ssh_key_remote_location }}"
      mode: 0600
    become: yes

  - name: "Wait for dns"
    shell: "nslookup {{ mig_dest_service_url }}"
    register: dig_output
    until: dig_output.rc == 0
    retries: 100
    delay: 3

  - name: "Synchronizing files. This may take a while..."
    shell: "rsync -aPvvH {{ mig_source_data_location }} -e 'ssh -p 2222 -o StrictHostKeyChecking=no -i {{ mig_dest_ssh_key_remote_location }}' {{ mig_dest_ssh_user }}@{{ mig_dest_service_url }}:{{ mig_dest_data_location }}"

    register: sync_output
    become: yes

  - name: "Removing private key from source node"
    file:
      path: "{{ mig_dest_ssh_key_remote_location }}"
      state: absent
    become: yes

  - name: "Stop stunnel"
    systemd: "stunnel"
    state: stopped

- name: "Collect failed pvcs"
  vars:
    failed_pvc:
      - name: "{{ pvc_name }}"
        namespace: "{{ pvc_ns }}"
        stdout: "{{ sync_output.stdout }}"
        stderr: "{{ sync_output.stderr }}"
        rc: "{{ sync_output.rc }}"
  set_fact:
    failed_pvcs: "{{ failed_pvcs +  failed_pvc }}"
  when: sync_output.rc != 0

- name: "Collect successful pvcs"
  vars:
    successful_pvc:
      - name: "{{ pvc_name }}"
        namespace: "{{ pvc_ns }}"
  set_fact:
    successful_pvcs: "{{ successful_pvcs +  successful_pvc }}"
  when: sync_output.rc == 0
